好的，我将根据您的PRD文档，为您输出一份结构设计文档。这份文档将侧重于软件的整体架构、模块划分、数据流和关键技术选型，以指导开发。

---

## 闪念速记 V2.0 结构设计文档

| 文档版本 | V1.0 |
|---|---|
| 创建日期 | 2025年8月29日 |
| 创建人 | Gemini (根据您的PRD生成) |
| 状态 | 草案 |

### 1. 总体架构

闪念速记 V2.0 将采用现代化的**Electron + React/MUI** 技术栈，结合本地 **SQLite** 数据库，构建一个高性能、可扩展的桌面应用。整体架构将遵循 **前端-后端分离** 的思想，其中 Electron 的 Main Process 充当轻量级“后端”，负责系统级操作和数据库交互，而 Renderer Process 则作为“前端”，负责 UI 渲染和用户交互。

**分层架构概览：**

```
+---------------------+
|      用户界面       | (Renderer Process / React + MUI)
+---------------------+
           |
+---------------------+
|   UI 状态管理 (Zustand) |
+---------------------+
           |
+---------------------+
|   API 抽象层 (preload.js)  |
+---------------------+
           |
+---------------------+
|   主进程业务逻辑    | (Main Process / Node.js)
+---------------------+
           |
+---------------------+
|   数据访问层 (DAO)   | (Main Process / Node.js)
+---------------------+
           |
+---------------------+
|     SQLite 数据库    | (notes.db)
+---------------------+
```
 

### 2. 模块划分

我们将应用划分为以下核心模块，每个模块承担特定的职责，以实现高内聚、低耦合。

#### 2.1 UI / 表现层 (Renderer Process)

*   **主窗口模块 (MainWindow):** 承载核心的笔记列表、编辑器和设置界面。
    *   `NoteList`: 负责展示笔记列表，包括搜索过滤、排序和删除操作。
    *   `NoteEditor`: Markdown 编辑器，支持实时预览和自动保存。
    *   `Settings`: 应用设置界面，包含通用设置、外观设置和数据导入/导出等。
    *   `Toolbar/Header`: 应用顶部导航和功能入口，如搜索框、新建笔记、主题切换等。
*   **悬浮球模块 (FloatBall):** 一个独立的、可拖动的悬浮球组件。
    *   `FloatBallUI`: 渲染悬浮球及其菜单，处理拖拽、点击事件。
    *   `QuickInputWindow`: 单击悬浮球弹出的快速输入窗口。
*   **独立笔记窗口模块 (DetachedNoteWindow):** 弹出式、置顶的单篇笔记窗口。
    *   `DetachedNoteEditor`: 独立窗口内的 Markdown 编辑器，与主编辑器共享逻辑。
*   **待办事项模块 (TodoView):** 独立的待办事项管理界面。
    *   `TodoList`: 展示待办事项列表。
    *   `TodoItem`: 单个待办事项的渲染和操作。
    *   `QuadrantView`: 四象限视图逻辑和渲染。
*   **通用组件库 (Components):** 可复用的 UI 组件，如按钮、对话框、图标等，基于 MUI 进行封装。
*   **状态管理 (State Management):** 使用 Zustand 管理全局 UI 状态，如当前选中的笔记、主题模式、搜索关键词等。

#### 2.2 主进程 / 业务逻辑层 (Main Process)

*   **窗口管理模块 (WindowManager):** 负责创建、管理和销毁所有 Electron 窗口（主窗口、悬浮球、独立笔记窗口等）。
*   **系统集成模块 (SystemIntegration):** 处理 Electron 特有的系统级操作。
    *   `AutoLaunchHandler`: 控制开机自启。
    *   `MenuHandler`: 定义应用菜单栏。
    *   `IPCMainHandler`: 监听和处理来自 Renderer Process 的 IPC 通信请求，并分发给相应的业务逻辑。
*   **笔记服务模块 (NoteService):** 核心业务逻辑，封装了笔记的 CRUD 操作、搜索、排序等。
    *   `createNote`, `getNoteById`, `updateNote`, `deleteNote`, `getAllNotes`, `searchNotes` 等方法。
*   **待办事项服务模块 (TodoService):** 待办事项的 CRUD 和排序逻辑。
    *   `createTodo`, `getTodoById`, `updateTodo`, `deleteTodo`, `getAllTodos` 等方法。
*   **数据导入模块 (DataImportService):** 负责解析 V1.x 的 `notes.json` 文件并导入到 SQLite。
*   **设置服务模块 (SettingsService):** 管理应用的所有设置，如主题、壁纸、开机自启状态等。
*   **插件加载模块 (PluginLoader):** 负责从本地目录加载并初始化第三方插件。

#### 2.3 数据访问层 (Data Access Layer - DAL)

*   **数据库管理器 (DatabaseManager):** 初始化 SQLite 数据库连接，管理数据库文件 (`notes.db`) 的生命周期。
*   **数据访问对象 (DAO):** 为每种数据实体提供 CRUD 接口，直接与 SQLite 进行交互。
    *   `NoteDAO`: 封装笔记数据的存储和检索逻辑。
    *   `TodoDAO`: 封装待办事项数据的存储和检索逻辑。
    *   `SettingDAO`: 封装应用设置的存储和检索逻辑。

#### 2.4 辅助工具与抽象层

*   **IPC 抽象层 (preload.js):** 作为 Renderer Process 和 Main Process 之间的桥梁。
    *   暴露一个经过安全沙箱处理的 `window.api` 对象，包含 Main Process 提供的所有业务方法，Renderer Process 通过它与 Main Process 通信。例如：`window.api.notes.createNote(...)`, `window.api.settings.getTheme()`, `window.api.data.importLegacyNotes(...)`。
*   **工具函数 (Utils):** 存放通用的辅助函数，如日期格式化、Markdown 解析/渲染辅助等。
*   **自定义 Hooks (Custom Hooks):** 封装可复用的 React 逻辑。

### 3. 数据流设计

#### 3.1 核心数据流 - 笔记编辑与保存

1.  **用户操作:** 用户在 Renderer Process 的 `NoteEditor` 中输入文本。
2.  **UI 状态更新:** 编辑器组件内部状态更新，同时可能触发 Zustand 中当前编辑笔记内容的更新（节流处理）。
3.  **自动保存触发:** 用户输入停止后（例如，通过 `debounce` 机制），`NoteEditor` 组件检测到内容变更。
4.  **IPC 通信:** `NoteEditor` 调用 `window.api.notes.updateNote(noteId, newContent)`。
5.  **主进程接收:** `IPCMainHandler` 接收到 `updateNote` 请求。
6.  **业务逻辑:** `NoteService` 调用 `NoteDAO.update(...)` 将新内容写入 SQLite 数据库。
7.  **数据库更新:** SQLite 数据库更新笔记内容和 `updated_at` 时间戳。
8.  **（可选）UI 反馈:** 数据库成功更新后，`NoteService` 可能通过 IPC 将成功消息返回给 Renderer Process，或触发一个事件，更新笔记列表中的 `updated_at` 和预览文本。

#### 3.2 旧数据导入流程

1.  **用户操作:** 用户在 `Settings` 界面点击“导入旧版本数据”。
2.  **文件选择:** Renderer Process 调用 `window.api.data.openFilePicker()`。
3.  **主进程打开对话框:** `SystemIntegration` 模块使用 Electron API 弹出文件选择对话框。
4.  **文件路径返回:** 用户选择 `notes.json` 后，文件路径通过 IPC 返回给 Renderer Process。
5.  **导入请求:** Renderer Process 调用 `window.api.data.importLegacyNotes(filePath)`。
6.  **主进程处理:** `IPCMainHandler` 接收请求，转发给 `DataImportService`。
7.  **数据解析与写入:** `DataImportService` 读取 `filePath` 的 JSON 文件，解析数据，然后批量调用 `NoteDAO.create(...)` 将数据写入 SQLite。
8.  **结果反馈:** 导入完成后，`DataImportService` 通过 IPC 将成功/失败消息返回给 Renderer Process。
9.  **UI 更新:** Renderer Process 显示导入结果提示，并刷新 `NoteList`。

#### 3.3 悬浮球快速输入流程

1.  **用户操作:** 单击屏幕边缘的 `FloatBall`。
2.  **窗口创建:** `FloatBallUI` 调用 `window.api.window.openQuickInputWindow()`。
3.  **主进程创建新窗口:** `WindowManager` 创建一个新的 `BrowserWindow` 实例，加载 `QuickInputWindow` 的 HTML/JS。
4.  **输入与保存:** 用户在 `QuickInputWindow` 中输入内容，触发自动保存逻辑（同笔记编辑）。
5.  **窗口关闭:** 用户关闭 `QuickInputWindow`。

### 4. 数据结构设计 (SQLite)

核心数据表：

#### 4.1 `notes` 表

| 字段名 | 类型 | 约束 | 描述 |
|---|---|---|---|
| `id` | TEXT | PRIMARY KEY | 笔记的唯一标识符 (UUID) |
| `title` | TEXT | NOT NULL | 笔记标题，默认为空 |
| `content` | TEXT | NOT NULL | 笔记的 Markdown 内容 |
| `created_at` | INTEGER | NOT NULL | 创建时间 (Unix Timestamp) |
| `updated_at` | INTEGER | NOT NULL | 最后更新时间 (Unix Timestamp) |
| `is_archived` | INTEGER | DEFAULT 0 | 软删除标记 (0: 正常, 1: 已归档/删除) |
| `is_pinned` | INTEGER | DEFAULT 0 | 置顶标记 (0: 否, 1: 是) (P1) |
| `tags` | TEXT | DEFAULT '[]' | 标签列表 (JSON 字符串) (P1) |
| `folder_id` | TEXT | NULL | 所属文件夹 ID (P1) |

#### 4.2 `todos` 表

| 字段名 | 类型 | 约束 | 描述 |
|---|---|---|---|
| `id` | TEXT | PRIMARY KEY | 待办事项的唯一标识符 (UUID) |
| `content` | TEXT | NOT NULL | 待办事项内容 |
| `is_completed` | INTEGER | DEFAULT 0 | 是否完成 (0: 未完成, 1: 已完成) |
| `is_important` | INTEGER | DEFAULT 0 | 是否重要 (0: 否, 1: 是) |
| `is_urgent` | INTEGER | DEFAULT 0 | 是否紧急 (0: 否, 1: 是) |
| `created_at` | INTEGER | NOT NULL | 创建时间 (Unix Timestamp) |
| `completed_at` | INTEGER | NULL | 完成时间 (Unix Timestamp) |
| `due_date` | INTEGER | NULL | 截止日期 (Unix Timestamp) (P1) |

#### 4.3 `settings` 表

| 字段名 | 类型 | 约束 | 描述 |
|---|---|---|---|
| `key` | TEXT | PRIMARY KEY | 设置项的键 (e.g., 'theme', 'auto_launch', 'wallpaper_path') |
| `value` | TEXT | NOT NULL | 设置项的值 (存储为 JSON 字符串或原始字符串) |

### 5. 技术选型

*   **核心框架:** Electron
*   **前端框架:** React 18+
*   **UI 组件库:** Material-UI (MUI v5+)
*   **状态管理:** Zustand
*   **数据库:** SQLite (通过 `better-sqlite3` 库在 Main Process 中使用)
*   **Markdown 编辑器:** 待选，可能集成 `react-markdown` + `remark` / `rehype` 生态或 `Monaco Editor` 搭配 Markdown 插件。
*   **打包工具:** Vite (或 Webpack)
*   **代码风格:** ESLint + Prettier
*   **测试框架:** Vitest (或 Jest)
*   **IPC 通信:** Electron's `ipcMain` / `ipcRenderer`

### 6. 非功能性需求实现策略

*   **性能 (启动速度、响应速度、内存占用):**
    *   **架构优化:** Main Process 仅处理核心业务逻辑和数据库操作，Renderer Process 专注于 UI 渲染，避免阻塞。
    *   **数据库优化:** SQLite 本身性能优异。针对大规模数据，使用索引、合理查询优化。
    *   **React 优化:** 严格遵循 React 性能最佳实践（`React.memo`, `useCallback`, `useMemo`），避免不必要的重渲染。Zustand 的 `selector` 机制有效减少渲染。
    *   **资源加载:** 懒加载、按需加载组件和资源。
    *   **内存管理:** 及时释放不再使用的对象，注意大型数据结构的引用。
*   **平台兼容性:** Electron 原生支持跨平台。针对 Windows 和 macOS 进行 UI 细节适配和系统级功能测试。
*   **可靠性 (无数据丢失、健壮性):**
    *   **自动保存:** 关键数据变更自动保存至 SQLite。
    *   **事务处理:** 批量操作（如数据导入）使用数据库事务，确保原子性。
    *   **异常处理:** 全局捕获未处理异常，记录日志，并友好提示用户。对文件操作、数据库操作进行严格的错误校验。
    *   **数据备份:** 考虑未来提供定期数据备份功能。
*   **易用性 (零学习成本、键盘友好):**
    *   **UI/UX 设计:** 遵循极简主义和一致性原则，MUI 提供良好基础。
    *   **快捷键:** 为所有核心操作（新建、保存、搜索、切换视图等）设计并实现快捷键。
    *   **用户反馈:** 及时提供操作反馈（加载动画、成功/失败提示）。

### 7. 插件化架构设计 (F10)

*   **核心理念:** 基于开放封闭原则，通过定义插件 API 和生命周期钩子，允许第三方扩展功能。
*   **插件目录:** 应用将扫描特定目录（例如：`./plugins`）加载插件。
*   **插件结构:** 每个插件是一个独立的文件夹，包含 `package.json`（描述插件信息）和 `index.js`（插件入口文件）。
*   **插件 API (Main Process):** `mainProcessPluginApi` 将提供以下能力：
    *   注册新的 IPC 处理器。
    *   注册新的数据库 DAO。
    *   访问核心服务的只读方法（例如 `noteService.getNoteById()`）。
*   **插件 API (Renderer Process):** `rendererProcessPluginApi` 将提供以下能力：
    *   注册新的 UI 组件（例如，在主窗口侧边栏、工具栏中插入自定义按钮或面板）。
    *   访问核心 Zustand Store 的只读状态。
    *   调用核心 `window.api` 的方法。
*   **生命周期钩子:** `onLoad`, `onActivate`, `onDeactivate` 等，供插件在不同阶段执行逻辑。

### 8. 未来规划的技术考量

*   **AI 智能助手 (F17):**
    *   预留 API 接口，允许 AI 服务通过 Main Process 访问笔记内容（需用户授权）。
    *   考虑使用 `node-fetch` 或 `axios` 在 Main Process 调用远程 AI API。
    *   用户协议框架在应用启动时或首次使用 AI 功能时弹出，明确数据使用权限。
*   **云端同步 (F21):**
    *   需要实现数据冲突解决机制 (Conflict Resolution)。
    *   WebDAV 或云服务 SDK 集成将在 Main Process 进行。
    *   考虑使用 `fs.watch` 或文件系统事件来触发同步。
*   **富文本支持 (F15):** 
    *   引入 `ProseMirror` 或 `Lexical` 等富文本编辑器框架，或在现有 Markdown 编辑器基础上集成图片上传和显示功能。图片将存储在本地文件系统，数据库中仅存储图片路径。
 

---

这份结构设计文档提供了一个高层次的视图，为闪念速记 V2.0 的开发奠定了基础。在实际开发过程中，每个模块和组件的细节还需要进一步细化和设计。