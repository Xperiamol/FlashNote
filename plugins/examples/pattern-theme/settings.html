<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>主题外观设置</title>
	<style>
		* {
			box-sizing: border-box;
		}
		body {
			margin: 0;
			padding: 0;
			font-family: 'Roboto', 'Helvetica', 'Arial', sans-serif;
			-webkit-font-smoothing: antialiased;
			-moz-osx-font-smoothing: grayscale;
		}
		#root {
			width: 100%;
			height: 100vh;
		}
		.loading {
			display: flex;
			align-items: center;
			justify-content: center;
			height: 100vh;
			font-size: 18px;
			color: #666;
		}
	</style>
</head>
<body>
	<div id="root">
		<div class="loading">正在加载主题外观设置...</div>
	</div>

	<script>
		// 等待主应用注入依赖
		function waitForDependencies(callback, maxAttempts = 100) {
			let attempts = 0
			console.log('[PatternSettings] 开始等待依赖注入...')
			
			const check = setInterval(() => {
				attempts++
				console.log(`[PatternSettings] 检查依赖 (尝试 ${attempts}/${maxAttempts}):`, {
					React: !!window.React,
					ReactDOM: !!window.ReactDOM,
					MaterialUI: !!window.MaterialUI,
					MaterialIcons: !!window.MaterialIcons,
					appTheme: !!window.appTheme
				})
				
				if (window.React && window.ReactDOM && window.MaterialUI) {
					clearInterval(check)
					console.log('[PatternSettings] ✅ 依赖加载成功!')
					callback()
				} else if (attempts >= maxAttempts) {
					clearInterval(check)
					console.error('[PatternSettings] ❌ 依赖加载超时')
					document.getElementById('root').innerHTML = 
						'<div class="loading" style="color: red;">❌ 依赖加载失败<br/>请确保插件在 FlashNote 中打开</div>'
				}
			}, 100)
		}

		// 当依赖就绪后初始化 React 应用
		waitForDependencies(() => {
			const { React, ReactDOM, MaterialUI, MaterialIcons, appTheme, emotionCache, CacheProvider } = window
			const { useState, useEffect, useRef } = React
			const {
				ThemeProvider,
				CssBaseline,
				Box,
				Typography,
				Button,
				Slider,
				Stack,
				Card,
				CardContent,
				CardActions,
				Grid,
				Chip,
				Alert,
				Switch,
				FormControlLabel,
				Divider,
				IconButton
			} = MaterialUI
			
			const { 
				Palette: PaletteIcon,
				Opacity: OpacityIcon,
				Check: CheckIcon,
				Upload: UploadIcon,
				Delete: DeleteIcon,
				Image: ImageIcon
			} = MaterialIcons

			// 花纹样式定义
			const PATTERN_STYLES = {
				custom: { name: '自定义图片', description: '上传你自己的壁纸图片', isCustom: true },
				dots: { name: '圆点', description: '经典的圆点背景，简约优雅' },
				grid: { name: '网格', description: '整齐的网格线条，适合笔记编辑' },
				diagonal: { name: '斜纹', description: '动感的斜向条纹，现代风格' },
				hexagon: { name: '蜂窝', description: '六边形蜂窝图案，科技感十足' },
				waves: { name: '波浪', description: '柔和的波浪纹理，舒缓视觉' },
				circuit: { name: '电路', description: '电路板风格，极客最爱' },
				zigzag: { name: '之字形', description: '锯齿状几何图案，活力四射' },
				diamonds: { name: '菱形', description: '菱形交错，对称美感' },
				trees: { name: '森林', description: '树木剪影，自然清新' },
				mountains: { name: '群山', description: '山峦起伏，壮阔开阔' },
				clouds: { name: '云朵', description: '飘逸云彩，轻盈柔和' },
				stars: { name: '星空', description: '点点繁星，浪漫神秘' },
				cityscape: { name: '城市', description: '都市建筑，现代时尚' },
				rain: { name: '细雨', description: '雨丝飘落，静谧安宁' },
				leaves: { name: '落叶', description: '叶片飘零，诗意浪漫' },
				ocean: { name: '海洋', description: '波光粼粼，宁静深邃' },
				bokeh: { name: '光斑', description: '虚化光点，梦幻朦胧' },
				sakura: { name: '樱花', description: '花瓣飘舞，温柔浪漫' },
				geometry: { name: '几何', description: '抽象图形，艺术感强' },
				paper: { name: '纸张', description: '纸质纹理，复古温馨' }
			}

			// 主应用组件
			function App() {
				const [settings, setSettings] = useState(null)
				const [loading, setLoading] = useState(true)
				const [saving, setSaving] = useState(false)
				const [message, setMessage] = useState(null)
					const [tempOpacity, setTempOpacity] = useState(1.0)
					const [tempEnabled, setTempEnabled] = useState(true)
					const [tempStyle, setTempStyle] = useState('dots')
					const [customImage, setCustomImage] = useState(null)
					const [uploadingImage, setUploadingImage] = useState(false)
					const fileInputRef = useRef(null)				// 加载当前设置
				useEffect(() => {
					loadSettings()
				}, [])

				const loadSettings = async () => {
					try {
						console.log('[PatternSettings] 加载设置...')
						// 传入 getSettings: true 来明确请求获取设置
						const result = await window.flashnotePlugin.executeCommand(
							'pattern-theme',
							'pattern-theme.settings',
							{ getSettings: true }
						)


						// 格式1: { success: true, data: { currentSettings: {...}, availableStyles: [...] } }
						if (result.data && result.data.currentSettings) {
							
							responseData = result.data
						}
						// 格式2: { success: true, currentSettings: {...}, availableStyles: [...] }
						else if (result.currentSettings) {
							
							responseData = result
						}
						else {
							console.error('[PatternSettings] 未知的数据格式')
							throw new Error('返回数据格式不正确')
						}
						
						
						
						if (responseData && responseData.currentSettings) {
							const current = responseData.currentSettings
							setSettings(responseData)
							setTempOpacity(current.opacity || 1.0)
							setTempEnabled(current.enabled !== false)
							setTempStyle(current.style || 'dots')
							setCustomImage(current.customImageUrl || null)

						} else {
							console.error('[PatternSettings] responseData 无效:', responseData)
							throw new Error('无法加载设置：缺少 currentSettings')
						}
					} catch (error) {
						console.error('[PatternSettings] ❌ 加载设置失败:', error)
						console.error('[PatternSettings] 错误堆栈:', error.stack)
						setMessage({ type: 'error', text: error.message || '加载设置失败' })
						// 即使加载失败，也设置默认值，避免页面无法使用
						setTempOpacity(1.0)
						setTempEnabled(true)
						setTempStyle('dots')
					}
					setLoading(false)
				}

				// 应用设置
				const handleApply = async () => {
					if (!settings || !settings.currentSettings) {
						setMessage({ type: 'error', text: '设置未加载，请刷新页面' })
						return
					}

					setSaving(true)
					setMessage(null)

					try {
					// 一次性发送所有设置
					const result = await window.flashnotePlugin.executeCommand(
						'pattern-theme',
						'pattern-theme.settings',
						{
							getSettings: true,						needsImageData: false, // 避免控制台输出base64							enabled: tempEnabled,
							style: tempStyle,
							opacity: tempOpacity,
							maskMode: 'full',
							customImage: customImage
						}
					)
						if (result.success) {
							setMessage({ type: 'success', text: '设置已应用！' })
							// 重新加载设置以确保同步
							await loadSettings()
						} else {
							throw new Error(result.error || '应用设置失败')
						}
					} catch (error) {
						console.error('[PatternSettings] ❌ 应用设置失败:', error)
						setMessage({ type: 'error', text: error.message || '应用设置失败' })
					}
					setSaving(false)
				}

				// 选择样式
				const handleSelectStyle = (styleId) => {
					setTempStyle(styleId)
					setMessage(null)
				}

				// 处理图片上传
				const handleImageUpload = (event) => {
					const file = event.target.files[0]
					if (!file) return

					// 检查文件类型
					if (!file.type.startsWith('image/')) {
						setMessage({ type: 'error', text: '请上传图片文件' })
						return
					}

					// 检查文件大小（限制5MB）
					if (file.size > 5 * 1024 * 1024) {
						setMessage({ type: 'error', text: '图片大小不能超过5MB' })
						return
					}

					setUploadingImage(true)
					setMessage(null)

					// 读取文件并转换为 Data URL
					const reader = new FileReader()
					reader.onload = async (e) => {
						const dataUrl = e.target.result
						setCustomImage(dataUrl)
						setTempStyle('custom')
						setUploadingImage(false)
						setMessage({ type: 'success', text: '图片上传成功！请点击"应用设置"保存' })
					}
					reader.onerror = () => {
						setUploadingImage(false)
						setMessage({ type: 'error', text: '图片读取失败' })
					}
					reader.readAsDataURL(file)
				}

				// 删除自定义图片
				const handleDeleteCustomImage = async () => {
					setCustomImage(null)
					if (tempStyle === 'custom') {
						setTempStyle('dots')
					}
					setMessage({ type: 'info', text: '已删除自定义图片，请点击"应用设置"保存' })
				}

				// 触发文件选择
				const handleUploadClick = () => {
					fileInputRef.current?.click()
				}

				if (loading) {
					return React.createElement(Box, {
						sx: {
							display: 'flex',
							alignItems: 'center',
							justifyContent: 'center',
							height: '100vh'
						}
					},
						React.createElement(Typography, null, '正在加载...')
					)
				}

				return React.createElement(ThemeProvider, { theme: appTheme },
					React.createElement(React.Fragment, null,
						React.createElement(CssBaseline),
						React.createElement(Box, {
							sx: {
								height: '100vh',
								bgcolor: 'background.default',
								overflow: 'auto'
							}
						},
							React.createElement(Box, { sx: { p: 3, maxWidth: 1000, mx: 'auto' } },
								// 标题
								React.createElement(Box, { sx: { mb: 3, textAlign: 'center' } },
									React.createElement(Typography, {
										variant: 'h4',
										sx: { 
											display: 'flex', 
											alignItems: 'center', 
											justifyContent: 'center',
											gap: 1,
											mb: 1
										}
									},
										React.createElement(PaletteIcon, { color: 'primary', fontSize: 'large' }),
										'主题外观设置'
									),
									React.createElement(Typography, {
										variant: 'body2',
										color: 'text.secondary'
									}, '自定义你的背景花纹样式和透明度')
								),

								// 消息提示
								message && React.createElement(Alert, {
									severity: message.type,
									sx: { mb: 2 },
									onClose: () => setMessage(null)
								}, message.text),

								// 开关
								React.createElement(Card, { sx: { mb: 3 } },
									React.createElement(CardContent, null,
										React.createElement(FormControlLabel, {
											control: React.createElement(Switch, {
												checked: tempEnabled,
												onChange: (e) => {
													setTempEnabled(e.target.checked)
													setMessage(null)
												}
											}),
											label: React.createElement(Typography, { variant: 'h6' }, '启用花纹效果')
										}),
										React.createElement(Typography, {
											variant: 'body2',
											color: 'text.secondary',
											sx: { ml: 5 }
										}, tempEnabled ? '花纹效果已启用' : '花纹效果已禁用')
									)
								),

								// 透明度调节
								React.createElement(Card, { sx: { mb: 3 } },
									React.createElement(CardContent, null,
										React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', gap: 1, mb: 2 } },
											React.createElement(OpacityIcon, { color: 'primary' }),
											React.createElement(Typography, { variant: 'h6' }, '透明度'),
											React.createElement(Chip, {
												label: `${Math.round(tempOpacity * 100)}%`,
												size: 'small',
												color: 'primary'
											})
										),
										React.createElement(Slider, {
											value: tempOpacity,
											onChange: (e, value) => {
												setTempOpacity(value)
												setMessage(null)
											},
											min: 0,
											max: 2,
											step: 0.1,
											marks: [
												{ value: 0, label: '0%' },
												{ value: 0.5, label: '50%' },
												{ value: 1, label: '100%' },
												{ value: 1.5, label: '150%' },
												{ value: 2, label: '200%' }
											],
											valueLabelDisplay: 'auto',
											valueLabelFormat: (value) => `${Math.round(value * 100)}%`
										}),
										React.createElement(Typography, {
											variant: 'caption',
											color: 'text.secondary',
											sx: { mt: 1 }
										}, '调整花纹的显眼程度，0% 为完全透明，200% 为加倍浓度')
									)
								),

								// 花纹样式选择
								React.createElement(Card, { sx: { mb: 3 } },
									React.createElement(CardContent, null,
										React.createElement(Typography, { variant: 'h6', sx: { mb: 2 } },
											'花纹样式'
										),
										
										React.createElement(Grid, { container: true, spacing: 2 },
											// 自定义图片样式卡片
											React.createElement(Grid, { item: true, xs: 12 },
												React.createElement(Card, {
													sx: {
														cursor: 'pointer',
														border: 2,
														borderColor: tempStyle === 'custom' ? 'primary.main' : 'divider',
														borderStyle: customImage ? 'solid' : 'dashed',
														transition: 'all 0.2s',
														'&:hover': {
															borderColor: 'primary.light',
															transform: 'translateY(-2px)',
															boxShadow: 3
														}
													},
													onClick: () => customImage && handleSelectStyle('custom')
												},
													React.createElement(CardContent, null,
														React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: customImage ? 2 : 0 } },
															React.createElement(Stack, { direction: 'row', alignItems: 'center', spacing: 1 },
																React.createElement(ImageIcon, { color: tempStyle === 'custom' ? 'primary' : 'action' }),
																React.createElement(Typography, { variant: 'subtitle1', fontWeight: 'bold' },
																	'自定义图片'
																),
																tempStyle === 'custom' && React.createElement(CheckIcon, { color: 'primary' })
															),
															React.createElement(Stack, { direction: 'row', spacing: 1 },
																React.createElement(Button, {
																	variant: customImage ? 'outlined' : 'contained',
																	size: 'small',
																	startIcon: uploadingImage ? null : React.createElement(UploadIcon),
																	onClick: (e) => {
																		e.stopPropagation()
																		handleUploadClick()
																	},
																	disabled: uploadingImage
																}, uploadingImage ? '上传中...' : (customImage ? '更换' : '上传图片')),
																customImage && React.createElement(Button, {
																	variant: 'outlined',
																	size: 'small',
																	color: 'error',
																	startIcon: React.createElement(DeleteIcon),
																	onClick: (e) => {
																		e.stopPropagation()
																		handleDeleteCustomImage()
																	}
																}, '删除')
															)
														),
														customImage ? 
															React.createElement(Box, {
																sx: {
																	width: '100%',
																	height: 150,
																	backgroundImage: `url(${customImage})`,
																	backgroundSize: 'cover',
																	backgroundPosition: 'center',
																	borderRadius: 1,
																	border: '1px solid',
																	borderColor: 'divider'
																}
															})
															:
															React.createElement(Typography, {
																variant: 'caption',
																color: 'text.secondary'
															}, '上传自定义壁纸图片（最大5MB，支持 JPG、PNG、WebP 等格式）'),
														// 隐藏的文件输入
														React.createElement('input', {
															ref: fileInputRef,
															type: 'file',
															accept: 'image/*',
															style: { display: 'none' },
															onChange: handleImageUpload
														})
													)
												)
											),

											// 预设样式网格
											Object.entries(PATTERN_STYLES)
												.filter(([id]) => id !== 'custom') // 排除自定义样式
												.map(([id, info]) =>
												React.createElement(Grid, { item: true, xs: 12, sm: 6, md: 4, key: id },
													React.createElement(Card, {
														sx: {
															cursor: 'pointer',
															border: 2,
															borderColor: tempStyle === id ? 'primary.main' : 'transparent',
															transition: 'all 0.2s',
															'&:hover': {
																borderColor: 'primary.light',
																transform: 'translateY(-2px)',
																boxShadow: 3
															}
														},
														onClick: () => handleSelectStyle(id)
													},
														React.createElement(CardContent, null,
															React.createElement(Box, { sx: { display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 1 } },
																React.createElement(Typography, { variant: 'subtitle1', fontWeight: 'bold' },
																	info.name
																),
																tempStyle === id && React.createElement(CheckIcon, { color: 'primary' })
															),
															React.createElement(Typography, {
																variant: 'caption',
																color: 'text.secondary'
															}, info.description)
														)
													)
												)
											)
										)
									)
								),

								// 当前设置信息
								settings && React.createElement(Card, { sx: { mb: 3, bgcolor: 'action.hover' } },
									React.createElement(CardContent, null,
										React.createElement(Typography, { variant: 'subtitle2', sx: { mb: 1 } },
											'当前设置'
										),
										React.createElement(Divider, { sx: { my: 1 } }),
										React.createElement(Stack, { spacing: 1 },
											React.createElement(Typography, { variant: 'body2' },
												`状态: ${settings.currentSettings.enabled ? '已启用' : '已禁用'}`
											),
											React.createElement(Typography, { variant: 'body2' },
												`样式: ${settings.currentSettings.styleName || '未知'}`
											),
											React.createElement(Typography, { variant: 'body2' },
												`透明度: ${Math.round((settings.currentSettings.opacity || 1) * 100)}%`
											)
										)
									)
								),

								// 操作按钮
								React.createElement(Stack, { direction: 'row', spacing: 2, justifyContent: 'flex-end' },
									React.createElement(Button, {
										variant: 'outlined',
										onClick: loadSettings,
										disabled: saving
									}, '重置'),
									React.createElement(Button, {
										variant: 'contained',
										size: 'large',
										onClick: handleApply,
										disabled: saving || !settings
									}, saving ? '应用中...' : '应用设置')
								)
							)
						)
					)
				)
			}

			// 渲染应用
			const root = ReactDOM.createRoot(document.getElementById('root'))
			
			if (emotionCache && CacheProvider && emotionCache.sheet && emotionCache.registered) {
				console.log('[PatternSettings] ✅ 使用 CacheProvider 包裹应用')
				root.render(
					React.createElement(CacheProvider, { value: emotionCache },
						React.createElement(App)
					)
				)
			} else {
				console.warn('[PatternSettings] ⚠️ emotionCache 无效，使用默认渲染')
				root.render(React.createElement(App))
			}
		})
	</script>
</body>
</html>

