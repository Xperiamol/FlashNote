闪念速记 V2.0 产品需求文档 (PRD)|| 文档版本 | V1.7 || 创建日期 | 2025年8月29日 || 创建人 | Gemini (根据您的需求生成) || 状态 | 草案 |1. 背景与目标1.1 项目背景当前的“闪念速记”应用（V1.x）已验证了其核心价值，但在技术架构上存在局限性，导致可维护性差、性能瓶颈日益明显，且难以扩展新功能。为了提供更卓越的用户体验和为未来的发展奠定坚实基础，我们决定进行一次彻底的重写，代号“V2.0”。1.2 项目目标V2.0 的核心目标是构建一款快速、可靠、美观且高度可扩展的现代化本地笔记应用。架构现代化：采用业界领先的技术栈（如 React, MUI, Zustand, SQLite），实现清晰、可扩展的软件架构。体验极致化：提供如丝般顺滑的操作体验、简洁美观的UI界面，并专注于核心的笔记记录功能。数据强健壮：用 SQLite 替换原有的 JSON 文件存储，从根本上解决大规模数据下的性能问题，并保证数据安全。用户平滑过渡：确保 V1.x 版本的用户可以通过简单操作，无损地将其笔记数据导入到 V2.0 中。2. 用户画像与场景2.1 目标用户高效知识工作者：特征：程序员、产品经理、作家、学生等，每天需要处理大量信息，注重效率。行为：习惯使用键盘快捷键，对软件的响应速度要求高，讨厌复杂臃肿的功能。痛点：需要一个能随时唤起、快速记录、易于整理和搜索的工具，来捕捉那些稍纵即逝的想法和重要的信息。2.2 典型用户场景场景一：灵感闪现 小王是一名程序员，在写代码时突然有了一个优化算法的思路。他单击屏幕上自定义过图标的悬浮球，一个简洁的窗口立刻弹出，他迅速用 Markdown 记录下思路，然后关闭窗口，继续投入工作，整个过程不超过15秒。场景二：会议纪要 产品经理小李正在参加一个重要的需求评审会。她打开“闪念速记”，将一篇笔记弹出为独立窗口并置顶，一边开会一边记录要点。场景三：数据迁移 老用户小张下载了全新的 V2.0 版本。他从菜单栏找到“从旧版本导入数据”选项，选择了他之前使用的 notes.json 文件。几秒钟后，他所有的笔记都完美地出现在了新应用中，保留了原有的内容和创建时间。3. 功能详述 (Features)我们将功能按优先级划分为 P0 ( MVP核心功能 ) 和 P1 ( 上线后快速迭代 )。3.1 P0 - MVP核心功能| 功能模块 | 功能点 | 详细描述与要求 || F1: 核心笔记管理 | 创建笔记 | - 点击“新建笔记”按钮或使用快捷键 Ctrl/Cmd + N，即可在笔记列表中创建一篇新笔记。- 新笔记自动获得焦点，标题默认为空，内容区提示用户输入。 ||  | 查看与编辑笔记 | - 在左侧笔记列表中单击一篇笔记，右侧编辑器区域会显示其完整内容。- 编辑器支持实时编辑，内容变更应自动保存。 ||  | 删除笔记 | - 在笔记列表中，可通过右键菜单或特定按钮删除笔记。- 删除前需有二次确认弹窗，防止误删。 ||  | 笔记列表 | - 应用左侧为笔记列表，默认按更新时间倒序排列。- 列表项应显示笔记标题和一小段正文预览。 || F2: Markdown 编辑器 | 基础 Markdown 支持 | - 编辑器必须支持所见即所得 (WYSIWYG) 或实时预览模式。- 至少支持：标题 (H1-H6)、粗体、斜体、删除线、无序/有序列表、引用、代码块、链接。 ||  | 自动保存 | - 用户输入停止后 1-2 秒内自动保存到本地数据库，无需手动保存。 || F3: 数据存储 | 本地数据库 | - 所有笔记数据存储在本地的 SQLite 数据库文件 (notes.db) 中。- 应用启动时加载数据库，关闭时安全关闭。 || F4: 旧数据导入 (关键) | 导入入口 | - 在应用的设置-更多设置里面提供明确的导入入口。 ||  | 导入流程 | 1. 用户点击入口，弹出文件选择器。2. 用户选择旧的 notes.json 文件。3. 应用读取并解析 JSON 文件。4. 将解析出的笔记数据批量写入 SQLite 数据库。5. 导入完成后，给予用户成功的提示，并刷新笔记列表。 ||  | 异常处理 | - 如果选择的文件格式不正确，或解析失败，应给予用户明确的错误提示。- 导入过程应有防重复机制，避免用户重复导入相同内容。 || F5: 全局搜索 | 搜索框 | - 在 UI 顶部或侧边栏提供一个清晰的搜索框。 ||  | 搜索逻辑 | - 支持根据标题和正文内容进行实时模糊搜索。- 搜索结果应在笔记列表中高亮显示或进行过滤。 || F6: 应用基础 | 窗口与布局 | - 现代化的自定义标题栏（包含最小化、最大化、关闭按钮）。- 经典的三栏式布局（或两栏式，可按需调整）。 ||  | 主题切换 | - 支持浅色 (Light) 和深色 (Dark) 两种主题模式，并可跟随系统设置。 ||  | 开机自启 | - 在设置-更多设置中提供“开机时自动启动”的开关选项。 || F7: 悬浮球与快捷入口 | 悬浮球 | - 应用启动后，屏幕边缘显示一个可拖动的悬浮球。- 悬浮球应能自动贴边，避免遮挡主要内容。 ||  | 快速输入 | - 单击悬浮球：立即弹出一个轻量级输入框，用于快速记录笔记。- 双击悬浮球：在不同的输入模式间切换（例如：笔记、待办事项、AI）。- 右键悬浮球：弹出菜单，显示核心功能入口（如：打开主窗口、切换模式等）。 || F8: 待办事项 (Todo) | 待办管理 | - 提供一个独立的待办事项视图。- 支持添加、编辑、标记完成和删除待办事项。- 完成的待办事项应有明显的划线或置灰效果。 ||  | 属性设置 | - 每个待办事项都可以被标记为“重要”和“紧急”两个维度。 ||  | 智能排序 | - 提供四象限视图，自动将待办按‘重要且紧急’、‘重要不紧急’、‘紧急不重要’、‘不重要不紧急’进行分类排序。- 在列表视图中，支持按截止日期或手动排序。 || F9: 独立笔记窗口 | 弹出窗口 | - 在每篇笔记的编辑器视图中，提供一个“独立显示”或类似的按钮。- 点击后，该笔记会以一个独立的、简约的窗口形式弹出。 ||  | 窗口控制 | - 独立窗口支持置顶（Always on Top）。- 窗口可以自由拖拽、移动和缩放尺寸。- 在独立窗口中对笔记的修改应实时同步回主应用。- 窗口状态持久化：关闭独立窗口时，其位置和尺寸将被记录。下次该笔记以独立窗口形式打开时，会自动恢复到上次关闭时的状态。 || F10: 插件化架构 | 核心可扩展性 | - 应用的核心功能（如编辑器、数据存储）应设计为可通过插件进行扩展或替换。- 定义一套清晰的插件 API 和生命周期钩子。 ||  | 本地插件加载 | - MVP 阶段支持从本地指定目录加载第三方插件，用于功能验证和早期开发者测试。 || F11: 高度自定义 | 个性化外观 | - 在设置-外观设置面板。- 应用壁纸：支持用户上传本地图片作为应用背景/壁纸，并可调整模糊度和亮度。- 主题颜色：允许用户通过颜色选择器自定义应用的主题色（如按钮、高亮文本等）。- 悬浮球定制：用户可以自定义悬浮球的背景颜色、透明度，并支持上传自定义图标。- 圆角设置：用户可以自定义多个主要模块的圆角。 |3.2 P1 - 上线后快速迭代F12: 标签系统 (Tagging)：允许用户为笔记添加一个或多个标签，并可以根据标签筛选笔记。F13: 笔记本/文件夹：允许用户创建文件夹来组织笔记，实现层级化管理。F14: 笔记置顶：可以将重要的笔记固定在列表的最上方。F15: 富文本支持：在编辑器中支持插入图片。F16: 日历视图 (Calendar View)：- 提供月/周日历视图。- 支持将笔记或待办事项关联到特定日期。- 在日历上直观地展示有活动安排的日期。F17: 笔记导入导出 (Note Import/Export)：- 导出功能：支持将单篇或多篇笔记导出为通用格式（如 Markdown, Plain Text）。支持批量导出所有笔记为一个压缩文件。- 导入功能：支持从 Markdown 文件导入笔记。4. 非功能性需求| 类别 | 要求 || 性能 | - 启动速度：冷启动时间应小于 2 秒。- 响应速度：所有 UI 操作（点击、输入、搜索）应在 100 毫秒内给予反馈。- 内存占用：在加载 1000 篇笔记的情况下，内存占用应低于 200MB。 || 平台兼容性 | - 首先支持 Windows 10/11 和 macOS 11+。 || 可靠性 | - 无数据丢失：在任何正常操作或意外退出（如系统关机）的情况下，都不能丢失用户已输入的数据。- 健壮性：导入超大 JSON 文件（例如包含 10000+ 条笔记）时，应用不应崩溃。 || 易用性 | - 零学习成本：核心功能应符合用户直觉，无需阅读手册即可上手。- 键盘友好：核心操作均应支持快捷键。 |5. 技术原则 (Technical Principles)为确保代码的长期可维护性、可读性和可扩展性，避免“屎山”代码的形成，所有代码编写工作必须严格遵循以下原则：5.1 SOLID 原则S - 单一职责原则 (Single Responsibility Principle)每个组件、函数或模块只做一件事。例如，数据获取逻辑应与 UI 渲染逻辑分离。NoteList 组件只负责展示笔记列表，而不应包含数据库查询的实现。O - 开放封闭原则 (Open/Closed Principle)软件实体（类、模块、函数）应该对扩展开放，对修改封闭。这与 F10: 插件化架构 紧密相关，新增功能应通过开发新插件来实现，而非修改核心代码。L - 里氏替换原则 (Liskov Substitution Principle)在 React 组件开发中，自定义组件应尽可能表现得像其基础组件。例如，一个自定义的 StyledButton 组件应能接收并正确处理标准 HTML <button> 元素的所有属性。I - 接口隔离原则 (Interface Segregation Principle)组件不应依赖于它不需要的 props。使用 Zustand Store 时，应通过 selector (useStore(state => state.field)) 精确订阅所需的状态，而不是订阅整个 store，以避免不必要的重渲染。D - 依赖倒置原则 (Dependency Inversion Principle)高层模块不应依赖于低层模块，二者都应依赖于抽象。UI 组件（高层）不应直接依赖 better-sqlite3（低层），而应依赖于通过 preload.js 暴露的抽象 API（如 window.notesAPI）。5.2 DRY 原则 (Don't Repeat Yourself)避免重复：任何重复出现的代码片段或逻辑都应被提取为可重用的单元。工具函数 (Utilities)：例如，日期格式化、文本截断等功能，应封装在 utils 目录下的函数中。自定义 Hooks：可重用的业务逻辑（如 API 请求、事件监听等）应封装为自定义 Hooks。通用组件 (Components)：在多个地方使用的 UI 元素（如按钮、对话框、图标）应被创建为通用组件，存放在 components 目录。6. 设计与体验原则极简主义：界面无任何不必要的元素，让用户专注于内容本身。速度优先：性能是核心体验，快是第一原则。一致性：遵循 MUI 设计规范，确保所有组件和交互模式在应用内保持一致。7. 未来规划 (V2.1 及以后)AI 智能助手：集成 AI 能力，提供笔记内容总结、智能问答、写作辅助、语义搜索等功能。AI 服务 API 及用户协议框架：预留标准化的 API 接口，允许未来的 AI 服务在用户明确授权（遵循服务协议）后，对笔记内容进行读取和操作，为实现深度 AI 功能（如自动整理、知识图谱构建）提供基础。智能提醒系统：为笔记和待办事项设置提醒。初期支持系统级通知，未来通过插件系统接入第三方服务（如微信、邮件）进行提醒。插件商店：在插件架构基础上，建立一个可视化的插件商店，允许用户浏览、安装、管理和评价第三方插件。云端同步：支持通过 WebDAV 或主流云服务（如 iCloud, Google Drive）进行多端同步。增强型搜索：利用 SQLite FTS5 实现全文检索，支持更复杂的搜索语法。跨平台：开发 Web 版 и 移动版 App。